# Wasm初手: AudioNoiseをブラウザで動かす

CのコードをそのままWebで動かしたい。そんな時の選択肢が **WebAssembly (Wasm)** だ。

今回は Linus Torvalds の [AudioNoise](https://github.com/torvalds/AudioNoise) をブラウザで動かすことを目標に、Wasm のセットアップから実際のビルドまでを記録する。

---

## なぜWasmか

### JavaScript版の限界

Bad Apple HTML では AudioNoise の **phaser だけ** を JavaScript に手動移植した。

| Cファイル | JS実装 |
|-----------|--------|
| phaser.h | ✓ |
| echo.h | ✗ |
| flanger.h | ✗ |
| distortion.h | ✗ |

全エフェクトを移植するのは大変だし、Cコードの `fastpow` などのビットハックは JS では再現が難しい。

### Wasmなら

- **Cコードをそのままコンパイル** → 移植作業ゼロ
- **ビット精度が同じ** → 元の音が再現できる
- **AudioWorklet と連携** → 低レイテンシ

---

## emscripten のセットアップ

Wasm をビルドするには **emscripten** が必要。

### 方法1: submodule として管理（推奨）

プロジェクトに emsdk を含めておくと、誰でも同じ環境でビルドできる。

```bash
cd /Users/aki/git.local/bad-apple-html
git submodule add https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
```

使うときは毎回:

```bash
source emsdk/emsdk_env.sh
```

### 方法2: グローバルインストール

```bash
# Homebrew (macOS)
brew install emscripten

# または手動クローン
git clone https://github.com/emscripten-core/emsdk.git ~/emsdk
cd ~/emsdk
./emsdk install latest
./emsdk activate latest
echo 'source ~/emsdk/emsdk_env.sh' >> ~/.zshrc
```

### 確認

```bash
emcc --version
# emcc (Emscripten gcc/clang-like replacement) 3.x.x
```

---

## プロジェクト構成

```
bad-apple-html/
├── index.html                    # 既存 (JS版 phaser)
├── wasm.html                     # Wasm版 UI
├── bad_apple_guitar_scores.json  # 楽譜データ
├── emsdk/                        # emscripten (submodule)
└── src/
    ├── Makefile                  # ビルド設定
    └── audionoise_wasm.c         # Cラッパー
```

---

## Cラッパーの設計

AudioNoise のエフェクトを Wasm から呼び出すためのインターフェース。

### audionoise_wasm.c

```c
#include <emscripten.h>

// AudioNoise のヘッダーをインクルード
#include "phaser.h"
#include "echo.h"
#include "flanger.h"
#include "distortion.h"

// JavaScript に公開する関数
EMSCRIPTEN_KEEPALIVE
void effect_init(float pot1, float pot2, float pot3, float pot4) {
    phaser_init(pot1, pot2, pot3, pot4);
}

EMSCRIPTEN_KEEPALIVE
float effect_step(float input) {
    return phaser_step(input);
}
```

`EMSCRIPTEN_KEEPALIVE` マクロで、関数が最適化で消されないようにする。

### エクスポート設定

```makefile
EXPORTED_FUNCS = '["_effect_init", "_effect_step", "_malloc", "_free"]'
```

C の関数名には `_` プレフィックスが付く。

---

## Makefile

```makefile
EMCC = emcc
AUDIONOISE_DIR = /Users/aki/git.local/AudioNoise

EMCC_FLAGS = -O2 \
    -s WASM=1 \
    -s EXPORTED_FUNCTIONS='["_effect_init", "_effect_step"]' \
    -s EXPORTED_RUNTIME_METHODS='["ccall", "cwrap"]' \
    -s MODULARIZE=1 \
    -s EXPORT_NAME="AudioNoiseModule"

audionoise.js: audionoise_wasm.c
    $(EMCC) $< -o $@ $(EMCC_FLAGS) -I$(AUDIONOISE_DIR)
```

### 主要フラグの意味

| フラグ | 意味 |
|--------|------|
| `-O2` | 最適化レベル2 |
| `-s WASM=1` | Wasm 出力を有効化 |
| `-s MODULARIZE=1` | ES Module として出力 |
| `-s EXPORT_NAME="..."` | モジュール名を指定 |
| `-s ALLOW_MEMORY_GROWTH=1` | メモリ動的拡張を許可 |

---

## ビルド

```bash
cd src

# emsdk を有効化
source ../emsdk/emsdk_env.sh

# ビルド
make
```

成功すると生成されるファイル:

- `audionoise.js` - JavaScript グルーコード
- `audionoise.wasm` - WebAssembly バイナリ

---

## JavaScript からの呼び出し

### 基本的な使い方

```javascript
// モジュールをロード
const Module = await AudioNoiseModule();

// 関数をラップ
const effect_init = Module.cwrap('effect_init', null, ['number', 'number', 'number', 'number']);
const effect_step = Module.cwrap('effect_step', 'number', ['number']);

// 初期化
effect_init(0.3, 0.3, 0.5, 0.5);

// サンプル処理
const output = effect_step(inputSample);
```

### AudioWorklet での使用

```javascript
class WasmProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.module = null;
        this.effect_step = null;
    }

    async init() {
        this.module = await AudioNoiseModule();
        this.effect_step = this.module.cwrap('effect_step', 'number', ['number']);
        this.module.ccall('effect_init', null, ['number', 'number', 'number', 'number'], [0.3, 0.3, 0.5, 0.5]);
    }

    process(inputs, outputs) {
        if (!this.effect_step) return true;

        const input = inputs[0][0];
        const output = outputs[0][0];

        for (let i = 0; i < output.length; i++) {
            output[i] = this.effect_step(input ? input[i] : 0);
        }
        return true;
    }
}
```

---

## パフォーマンス考慮

### サンプル単位 vs バッファ単位

```c
// サンプル単位（遅い）
float effect_step(float input);

// バッファ単位（速い）
void effect_process_buffer(float* buffer, int length);
```

JavaScript ↔ Wasm の呼び出しにはオーバーヘッドがある。バッファ単位で処理する方が効率的。

### メモリ共有

```javascript
// Wasm メモリに直接書き込み
const bufferPtr = Module._malloc(128 * 4);  // Float32 × 128
const heap = new Float32Array(Module.HEAPF32.buffer, bufferPtr, 128);

// コピー
heap.set(inputBuffer);

// 処理
Module.ccall('effect_process_buffer', null, ['number', 'number'], [bufferPtr, 128]);

// 結果を取得
outputBuffer.set(heap);

// 解放
Module._free(bufferPtr);
```

---

## トラブルシューティング

### emcc not found

```bash
source emsdk/emsdk_env.sh
```

### undefined symbol

エクスポート設定を確認:

```makefile
-s EXPORTED_FUNCTIONS='["_関数名"]'
```

### AudioWorklet で Wasm が動かない

AudioWorklet 内では `fetch` が使えない。Wasm をインラインで埋め込むか、メインスレッドでロードして転送する。

---

## GitHub Pages で公開

Wasm は `file://` では動作しない（CORS制限）。HTTP/HTTPS が必須。

GitHub Pages を使えば簡単にHTTPS環境が手に入る:

1. `docs/` フォルダに公開ファイルを配置
2. Settings → Pages → Source: `main` branch `/docs`
3. `https://username.github.io/repo-name/` でアクセス可能

**file:// で動かしたい場合**: `wasm_base64.html` を使う（Wasmがbase64埋め込み）

## 完成したもの

**ライブデモ**: https://akihiko.shirai.as/bad-apple-html/

### 実装した機能

- [x] 全7エフェクト（phaser, echo, flanger, distortion, fm, am, discont）をWasmで動作
- [x] リアルタイムエフェクト切り替え
- [x] マルチチャンネル楽譜再生
- [x] オシロスコープ表示
- [x] `file://` でも動作（SINGLE_FILE=1でbase64埋め込み）

### 遭遇した問題と解決

**Flanger/Echoが動かない問題**

元の `effect_set_delay()` は `target_effect_delay` を設定するだけで、実際の `effect_delay` は `convert.c` の `UPDATE()` マクロで毎サンプル更新される設計だった。Wasmではこのループがないので、初期化時に即座に同期する関数を追加:

```c
static void sync_effect_delay(void) {
    extern float effect_delay, target_effect_delay;
    effect_delay = target_effect_delay;
}
```

---

## Wasm実装の意義

### なぜ今Wasmなのか

1. **C資産の再利用**: 30年分のDSPライブラリがブラウザで動く
2. **ビット精度の保証**: JSへの手動移植では失われる `fastpow` 等のビットハックも正確に再現
3. **デモの永続性**: URLを開くだけで動作。環境構築不要
4. **教育価値**: LinusのコードをインタラクティブVにに学べる

### JSON楽譜フォーマットの汎用性

`bad_apple_guitar_scores.json` は MIDI → JSON 変換の参考実装として使える:

```json
{"f": 440.0, "d": 0.25}  // 周波数(Hz), 持続時間(秒)
```

シンプルなフォーマットで:
- Web Audio シンセサイザー
- 音楽可視化
- リズムゲーム
- 着メロ生成

などに応用可能。

---

## 次のステップ（やりたいこと）

- [ ] YouTube動画を撮影してREADMEに埋め込み
- [ ] torvalds/AudioNoise に Issue で報告
- [ ] エフェクトチェーン（複数エフェクト直列）
- [ ] MIDI入力のリアルタイム処理

---

## 参考リンク

- [emscripten Documentation](https://emscripten.org/docs/)
- [WebAssembly MDN](https://developer.mozilla.org/en-US/docs/WebAssembly)
- [AudioWorklet + Wasm](https://developer.chrome.com/blog/audio-worklet/)
- [torvalds/AudioNoise](https://github.com/torvalds/AudioNoise)
