# 2026-01-16 作業ログ


今日も全力で働いていた。AIで開発や出版や執筆や法務や経理をすごい速度でこなしているのだけど、ときどきトボけた日本のビジネスパーソンが、とても不思議なことを書いてくるので、「？？？」となりつつも感情を全く廃して営業担当AIとかに相談している。うちの会社としては営業担当AIを、ChatGPTやGeminiが担当しておりまして、お互いに異なるモデルで、会話がコンプライアンスにあっているか、とか会社的に失礼ではないかとか、不可逆なことをしていないかとか、AI時代の新しいビジネスをいろんな視点でビジネスを垂直に成立させるために日夜努力している。そんな時、とてもおもしろい1行をもらったので共有しておく。

人が足りない時代に、人を選別するための儀式だけが高度化している。

いやほんとそれよね。そんなしょーもない日本の商習慣や、コンプライアンスにも合致していないようなビジネスは、淘汰されていることに気づこう。労働というロールの中にわざわざ浸っていることでサラリーを得られる良い時代というものが昔はあったのですが、AIを使って最小限のチームで自分の会社を回したりするレベルのところにいると、もうすでに「雇われている人」などはほとんどいなくなる。みんなが自分のために会社という法人を使う存在になっている。尊い。

Linus Torvaldsがおもしろい

さて、そんなしょーもない日本のビジネスに貢献する話とは別に、バイブコーディングの世界は本当に面白い。LinuxをつくったLinus Torvaldsが最近めっちゃ手のひら返していておもしろい。

2025年12月9日に、都内で開催されたLinux Foundation主催によるイベント「Open Source Summit Japan」の基調講演にLinuxの作者として知られるリーナス・トーバルズ氏が登壇



要約すると

1. 「魔法」ではなく「便利な道具」として見ているリーナス氏は、猫も杓子もAIという現在の「過剰な宣伝（ハイプ）」にはうんざりしています。しかし、AI技術そのものを否定しているわけではなく、むしろ「ツールとしては大いに信じている」と語っています。2. 「コードを書く」ことより「バグを見つける」ことに期待ここが非常に彼らしい視点です。書くこと: 「AIにコードを書かせる」ことにはあまり興味がありません。チェックすること: メンテナー（管理者）として、「送られてきたコードのミスやバグをAIに発見させる（コードレビュー）」ことに大きな可能性を感じています。実例: 実際に開発中のAIツールを見た際、専門家である彼自身が気づいた点に加え、さらに別の問題点もAIが指摘したことに感銘を受け、「このツールが欲しい」と思ったそうです。3. AIは「コンパイラ」と同じような進化の過程にすぎない彼はAIを特別視しすぎないよう釘を刺しています。昔、人間が機械語を書いていた時代に「コンパイラ（人間が書いたコードを機械語に翻訳するツール）」が登場したことで、プログラミング効率は1000倍になりました。それに比べれば、AIによる効率化は10倍〜100倍程度であり、**「コンパイラの登場に比べれば、AIはそれほど特別ではない（革命的というほどではない）」**としています。AIはあくまで「仕事を楽にするための新しい強力なツール」という位置づけです。まとめリーナス氏は、AIを「仕事を奪う脅威」や「魔法の杖」としてではなく、「Linuxカーネルの品質を高め、管理者の負担を減らすための実用的な道具」として冷静に評価し、導入に前向きであるということです。

一体なんのツールをレビューしているのかわからないけど、これからは本当に「AIとチーム」とかコードレビューが大事な時代になると思う。僕はCodeRabbitが2000年ぐらいにあったら、Linusはどんなに楽になっただろう！と思うよ

面白いな、と思うのは、Linusぐらいの伝説の開発者になると、ちょっとGitHubで何かやると騒ぎになるってこと。

Redditで騒ぎになってた「Linus Thorvald が Antigravity を使ってる！」

r/programming 4日前、1/11（つまり舌の根が乾かぬうちに）Practical-Rub-1190　Linus Thorvald が Antigravity を使ってる

https://www.reddit.com/r/programming/comments/1qa7uvv/linus_thorvald_using_antigravity/?tl=ja

で、AudioNoiseのコードを見てみた

https://github.com/torvalds/AudioNoise

このコードは2025年9月に書かれているギターペダルに関するCのコード。

## ギターペダル関連のくだらないリポジトリデジタル[RP2354とTAC5112ベースのギターペダル](https://github.com/torvalds/GuitarPedal)は、実際にはちゃんと動作します。アナログインターフェースの選択（特にポット）には満足していませんが（クリック式のフットスイッチは、プログラミング用のブートセレクタースイッチとしても使える点は気に入っていますが）、それでもです。ハードウェア設計はアーカイブ化され、生命と物理的なユーザーインターフェースの謎について考えながら作業を進めていますが、デジタルエフェクトについては今でも検討中です。ただ、今は純粋に「すべてデジタルなので、シミュレーションしてハードウェアはあまり気にしないようにしよう」という感じです。これらは、私の旅の始まりとなったアナログ回路と同様に、おもちゃのようなエフェクトであり、真剣に考えるべきではありません。設計の主な目標は、デジタルオーディオ処理の基礎を学ぶことでした。ギターペダルがハードウェア側の学習を目的としていたのと全く同じです。つまり、FFTベースの凝ったボコーダーなどは使わず、IIRフィルターと基本的なディレイループだけです。すべてが「単一サンプル入力、単一サンプル出力、レイテンシーなし」です。サンプルはディレイループに保存され、後で（各エフェクトごとに）参照されますが、実際には何も処理されていません。TAC5112がADC->DACチェーンに入力する際のレイテンシーが1ms未満だったことに満足していましたが、これもまさにそれを継承するものです。しかも、私はこれまでこのようなことをやったことがないので、私が初心者というだけで、すべてが非常に基本的でシンプルです。言い換えれば、IIRフィルターは、現代のペダルやギターアンプのような、AIによる「キャブをエミュレートする」ような凝ったものではありません。いいえ、フェイザーのようなアナログ回路をエミュレートはしますが、RCネットワークの効果をデジタルオールパスフィルタでエミュレートしているだけで、実際に*賢い*ことをしているわけではありません。また、Pythonビジュアライザーツールは基本的にvibe-codingによって作成されていることにも注意してください。私はアナログフィルタについて（といっても大したことではありませんが）Pythonよりも詳しいです。最初はいつもの「Googleで検索して猿真似をする」ようなプログラミングから始めましたが、その後、仲介者（つまり私自身）を排除し、Google Antigravityを使ってオーディオサンプルビジュアライザーを作成しました。

RP2354ってのはRaspberryPiのRP2040の後継世代にあたる新マイクロコントローラ（MCU）のことかな？

https://www.raspberrypi.com/news/rp2350-a4-rp2354-and-a-new-hacking-challenge/

TAC5112 は、アメリカの半導体メーカー Texas Instruments（TI） の 低消費電力ステレオオーディオコーデック（音声の入出力処理IC） 。これを使ってギターペダルを作っているらしい。

 AudioNoiseの概要

RP2354 + TAC5112ベースのギターペダルのデジタルエフェクト部分をシミュレーション

ハードウェアを気にせず純粋にデジタル処理を学ぶためのプロジェクト

「シングルサンプルin、シングルサンプルout、レイテンシなし」が設計方針

  技術的特徴

FFTベースの高度な処理は使わず、IIRフィルターとディレイループのみ

フェイザーなどのアナログ回路をデジタルオールパスフィルターでエミュレート

TAC5112のサブミリ秒レイテンシを継承した設計思想

  面白いポイント

  Linus本人が1980年代の技術をあえて、2026年の技術まですっ飛ばして「Pythonのビジュアライザーはvibe-codingで書いた」「Google Antigravity（AI）に任せた」と書いているのが印象的です。硬派なカーネル開発者でもAIを活用してるんですね。

  AiCutyのNaoくんとコードを解析して味わっていたら、めっちゃ面白くて、気がついたらこんなものができていた。

https://youtu.be/1kPKrw_lNNM

Bad Apple HTMLは、このAudioNoiseのフェイザーエフェクトのコア部分をWebAudioに移植して、Bad Apple!!のMIDIデータを再生できるようにしたものということですね。

Bad Apple HTML

概要

Bad Apple!! の公開MIDIから抽出したギターパートを、WebAudioのフェイザーで再生するデモを制作。AudioNoiseの設計思想に敬意を払いつつ、ブラウザで再生できる形に落とし込んだ。

進捗

MIDIを解析し、全チャンネルのスコアをJSON中間形式に整理。

UIでチャンネルをチェックボックスON/OFFして試聴できるように拡張。

再生状態が分かるようステータス表示と進行バーを追加。

WebAudioはDSP(Worklet)とUIを分離し、後から拡張できる構造にした。

こだわり

クリックノイズを避けるため、ゲインと周波数は`setTargetAtTime`で平滑化。

チャンネル数に応じて自動で音量を正規化し、歪みを抑制。

旧来の`file://`アクセスでも動作するよう、JSONの埋め込みフォールバックを用意。

データ/クレジット

MIDI入手元: https://github.com/CalvinLoke/bad-apple （`alstroemeria_records_bad_apple.mid`）

Bad Apple!! 原曲: ZUN（東方Project）

Bad Apple!! MV: Alstroemeria Records

MIDIアレンジ: Ronald Macdonald

AudioNoise: Linus Torvalds（GPL-2.0）

まだやりたいこと

チャンネルのSolo/Group再生。

コード再生（複数オシレータ）への拡張。

エフェクト構成の最適化（Dry/Wet、Limiterの導入など）。


## AudioNoise/visualize.py の解析

Linus Torvaldsの AudioNoise プロジェクトに含まれるオーディオ波形ビジュアライザー。

### 概要

- **目的**: 生のオーディオバイナリファイル（int32形式）を波形として可視化
- **ライブラリ**: numpy + matplotlib
- **設計思想**: 大きなファイルでもメモリ効率よく表示（mmap使用）

### 主要クラス: `WaveformVisualizer`

```
WaveformVisualizer(filenames, rate, min_zoom_samples)
```

| パラメータ | デフォルト | 説明 |
|-----------|-----------|------|
| filenames | (必須) | 入力ファイルのリスト |
| rate | 48000 | サンプルレート (Hz) |
| min_zoom_samples | 100 | 最小ズーム時のサンプル数 |

### ファイル形式

- **フォーマット**: raw int32 バイナリ（.bin）
- **1サンプル**: 4バイト (BYTES_PER_SAMPLE = 4)
- **正規化**: int32 → float32 (-1.0 〜 1.0)
  ```python
  normalized = chunk.astype(np.float32) / 2147483648.0
  ```

### メモリマップ読み込み

```python
mm = np.memmap(f, dtype=np.int32, mode='r', shape=(samples,))
```

ファイル全体をメモリにロードせず、必要な部分だけアクセス。大きなオーディオファイルでも効率的。

### UI機能

| 操作 | 動作 |
|------|------|
| スライダー | 時間位置の移動 |
| スクロール | ズームイン/アウト（マウス位置中心） |
| 矢印キー (←→) | X軸方向に25%移動 |
| 矢印キー (↑↓) | Y軸方向に25%移動 |
| PageDown | ズームイン (0.5倍) |
| PageUp | ズームアウト (2倍) |
| スペース | Y軸を自動スケール |
| 矩形選択 | 選択範囲にズーム |

### 定数

```python
INITIAL_WINDOW_SEC = 2.0   # 初期表示幅
MAX_WIDTH_SEC = 2.0        # 最大ズームアウト幅
```

### 使い方

```bash
python visualize.py audio1.bin audio2.bin --rate 48000
```

複数ファイルを同時に表示可能（凡例で区別）。

### 特徴的な実装

1. **navigating フラグ**: イベントの再帰呼び出しを防止
2. **マーカー表示**: 300サンプル以下の場合、個々のサンプル点を表示
3. **対称Y軸**: 音声波形は0を中心に対称表示
4. **スライダー同期**: xlim変更時にスライダーを静かに更新（イベント発火防止）

### 備考

README.mdでLinusが「vibe-codingで書いた」と述べているのはこのファイル。AI（Google Antigravity = おそらくGemini）を使って作成されたとのこと。

---

## visualize.py の起動テスト

### 手順

```bash
cd /Users/aki/git.local/AudioNoise

# 仮想環境を作成
python3 -m venv .venv
source .venv/bin/activate
pip install numpy matplotlib

# Makefileでビルド＆実行
make visualize
```

### 処理フロー

```
BassForLinus.mp3
    ↓ ffmpeg (s32le, 48kHz, mono)
input.raw
    ↓ ./convert echo 0.3 0.3 0.3 0.3
output.raw
    ↓ visualize.py
[matplotlib ウィンドウ]
```

### 確認できたこと

- 4つの波形を同時表示: input, output, magnitude, outmagnitude
- スクロールでズーム、スライダーで時間移動が動作
- echoエフェクトによる遅延と減衰が視覚的に確認できた

---

## Makefile の解説

AudioNoiseのMakefileは、オーディオ処理パイプラインを簡潔に記述した良い例。

### コンパイラ設定

```makefile
CC = gcc
CFLAGS = -Wall -O2 -ffast-math -fsingle-precision-constant
LDLIBS = -lm
```

| フラグ | 意味 |
|--------|------|
| `-Wall` | 全警告を有効化 |
| `-O2` | 最適化レベル2 |
| `-ffast-math` | 浮動小数点の厳密性を緩めて高速化（NaN/Inf処理を省略など） |
| `-fsingle-precision-constant` | `0.5` を `0.5f` として扱う（GCC専用、clangでは警告） |
| `-lm` | 数学ライブラリをリンク |

コメントアウトされている `-Wdouble-promotion` と `-Wfloat-conversion` は、floatとdoubleの暗黙変換を警告するオプション。デバッグ時に有用。

### 再生コマンド

```makefile
PLAY = ffplay -v fatal -nodisp -autoexit -f s32le -ar 48000 -ch_layout mono -i pipe:0
```

| オプション | 意味 |
|------------|------|
| `-v fatal` | ログ出力を最小限に |
| `-nodisp` | ウィンドウを表示しない |
| `-autoexit` | 再生終了後に自動終了 |
| `-f s32le` | 符号付き32bit リトルエンディアン |
| `-ar 48000` | サンプルレート 48kHz |
| `-ch_layout mono` | モノラル |
| `-i pipe:0` | 標準入力から読み込み |

### エフェクト定義

```makefile
effects = flanger echo fm phaser discont am distortion

flanger_defaults = 0.6 0.6 0.6 0.6
echo_defaults = 0.3 0.3 0.3 0.3
...
```

各エフェクトに4つのパラメータ（pot1〜pot4）のデフォルト値を設定。ギターペダルの4つのノブに対応。

### 主要ターゲット

#### `make` (default)
```makefile
default:
	@echo "Pick one of" $(effects)
```
使い方を表示するだけ。

#### `make <effect>` (例: `make phaser`)
```makefile
$(effects): input.raw convert
	./convert $@ $($@_defaults) < input.raw > output.raw
	ffmpeg -y -v fatal -f s32le -ar 48000 -ac 1 -i output.raw -f mp3 $@.mp3
	$(PLAY) < output.raw
```

1. `input.raw` にエフェクトを適用 → `output.raw`
2. MP3に変換して保存（`phaser.mp3` など）
3. ffplayで即座に再生

`$@` はターゲット名、`$($@_defaults)` は `phaser_defaults` などを展開する二重展開。

#### `make visualize`
```makefile
visualize: input.raw output.raw magnitude.raw outmagnitude.raw
	$(PYTHON) visualize.py input.raw output.raw magnitude.raw outmagnitude.raw
```
4つの波形ファイルを生成してビジュアライザを起動。

#### `make play`
```makefile
play: output.raw
	$(PLAY) < output.raw
```
既存の `output.raw` を再生。

### ファイル変換ルール

#### MP3 → RAW (汎用パターン)
```makefile
%.raw: %.mp3
	ffmpeg -y -v fatal -i $< -f s32le -ar 48000 -ac 1 $@
```
任意の `.mp3` を `.raw` に変換。`$<` は依存ファイル、`$@` はターゲット。

#### input.raw (明示的ルール)
```makefile
input.raw: BassForLinus.mp3
	ffmpeg -y -v fatal -i $< -f s32le -ar 48000 -ac 1 $@
```
`BassForLinus.mp3` → `input.raw` の固定変換。

### magnitude (振幅エンベロープ)

```makefile
magnitude.raw: input.raw convert
	./convert magnitude 0.1 0.0001 0 0 < input.raw > magnitude.raw
```

`magnitude` は特殊なエフェクトで、波形の振幅（エンベロープ）を抽出。ビジュアライザで波形の「輪郭」を見るために使用。

### コード生成

```makefile
gensin.h: gensin
	./gensin > gensin.h

gensin: gensin.c
```

`gensin.c` をコンパイル・実行して、サイン波のルックアップテーブル（`gensin.h`）を生成。LFO用の高速サイン計算に使用。

### SeymourDuncan ターゲット

```makefile
SeymourDuncan: convert
	for i in ~/Wav/Seymour\ Duncan/*; do \
		ffmpeg ... | ./convert phaser ... | $(PLAY) ; \
	done
```

Linusの `~/Wav/Seymour Duncan/` フォルダにあるサンプル音源を連続再生。個人的なテスト用ターゲット。

### .PHONY

```makefile
.PHONY: default play $(effects) SeymourDuncan visualize
```

ファイル名と衝突しないターゲットを宣言。`phaser` というファイルがあっても `make phaser` が動作する。

### 設計の特徴

1. **パイプライン指向**: stdin/stdout でデータを流す Unix哲学
2. **即時再生**: エフェクト適用後すぐに音を確認できる
3. **最小依存**: ffmpeg と gcc だけで動作
4. **パラメータ外出し**: デフォルト値を変数化して見通しよく

---

## C実装の解析

AudioNoiseのCコードはヘッダーオンリー設計。`convert.c` が全ヘッダーをインクルードし、単一バイナリにコンパイル。

### アーキテクチャ

```
convert.c
    ├── util.h      ... 高速数学、ディレイライン、sin/cosテーブル
    ├── lfo.h       ... 低周波オシレータ
    ├── biquad.h    ... デジタルフィルタ (IIR)
    ├── effect.h    ... 共通エフェクト状態
    ├── process.h   ... 入出力変換、ノイズゲート
    └── *.h         ... 各エフェクト実装
```

### util.h - ユーティリティ

#### 高速べき乗 `fastpow`

```c
static inline float fastpow(float a, float b)
{
    union { float f; int i; } u = { a };
    u.i = (int) (b * (u.i - 1072632447) + 1072632447.0f);
    return u.f;
}
```

IEEE 754浮動小数点のビットパターンを直接操作する有名なハック。対数の性質を利用して `a^b` を近似。精度は低いが高速。

#### ソフトリミッター `limit_value`

```c
static inline float limit_value(float x)
{
    float x2 = x*x;
    float x4 = x2*x2;
    return x*(1 - 0.19*x2 + 0.0162*x4);
}
```

入力 -2〜2 を出力 -1〜1 に滑らかに圧縮。多項式近似によるソフトクリッピング。

#### ディレイライン

```c
#define SAMPLE_ARRAY_SIZE 65536  // 約1.3秒 @ 48kHz
float sample_array[SAMPLE_ARRAY_SIZE];

static inline float sample_array_read(float delay)
{
    int i = (int) delay;
    float frac = delay - i;
    // 線形補間
    float a = sample_array[idx];
    float b = sample_array[idx+1];
    return a + (b-a)*frac;
}
```

リングバッファ + 線形補間で分数サンプルのディレイを実現。

### lfo.h - 低周波オシレータ

32ビット位相アキュムレータ方式。

```c
struct lfo_state {
    uint idx, step;  // 位相, 増分
};

float lfo_step(struct lfo_state *lfo, enum lfo_type type)
{
    uint now = lfo->idx;
    lfo->idx = now + lfo->step;
    // ... 波形生成
}
```

| 波形 | 説明 |
|------|------|
| `lfo_sinewave` | 1/4サイン波テーブル補間 |
| `lfo_triangle` | 三角波 |
| `lfo_sawtooth` | のこぎり波 |

周波数設定:
```c
// lfo_step = freq * (2^32 / 48000)
set_lfo_freq(&lfo, 1.5);  // 1.5 Hz
set_lfo_ms(&lfo, 500);    // 周期500ms = 2Hz
```

### gensin.h - サイン波テーブル

`gensin.c` が生成するルックアップテーブル。

```c
#define QUARTER_SINE_STEP_SHIFT 8  // 256エントリ
const float quarter_sin[] = {
    +0.00000000f, +0.00613588f, +0.01227154f, ...
};
```

1/4周期（0〜90度）だけ保存し、対称性で全周期をカバー。

### biquad.h - デジタルフィルタ

双2次（biquad）フィルタの実装。Direct Form 1。

```c
struct biquad_coeff {
    float b0, b1, b2;  // フィードフォワード係数
    float a1, a2;      // フィードバック係数
};

// y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]
```

| フィルタ | 用途 |
|----------|------|
| `biquad_lpf` | ローパス（高域カット） |
| `biquad_hpf` | ハイパス（低域カット） |
| `biquad_notch_filter` | ノッチ（特定周波数除去） |
| `biquad_bpf` | バンドパス |
| `biquad_allpass_filter` | オールパス（位相のみ変化）← **フェイザーの核心** |

### process.h - 入出力処理

```c
#define SAMPLE_TO_FLOAT_MULTIPLIER (1.0 / 0x80000000)

static inline float process_input(s32 sample)
{
    // int32 → float (-1.0 〜 1.0)
    // + 適応ノイズゲート
    return sample * noise_gate;
}
```

ノイズゲートは信号レベルを追跡し、無音時にゲインを下げてノイズを抑制。

---

## エフェクト実装詳細

### パラメータの意味（4つのpot）

各エフェクトは4つのパラメータ（pot1〜pot4）を受け取る。ギターペダルの4つのノブに対応。

#### echo (エコー/ディレイ)

```
echo_defaults = 0.3 0.3 0.3 0.3
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | ディレイ時間 | 0〜1000 ms |
| pot2 | (未使用) | - |
| pot3 | LFO深さ | 0〜4 ms |
| pot4 | フィードバック | 0〜100% |

```c
float echo_step(float in) {
    float out = sample_array_read(effect_delay);
    sample_array_write(in + out * effect_feedback);
    return (in + out) / 2;
}
```

#### flanger (フランジャー)

```
flanger_defaults = 0.6 0.6 0.6 0.6
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | LFO周波数 | 0〜10 Hz (2乗) |
| pot2 | ディレイ | 0〜4 ms |
| pot3 | 深さ | 0〜100% |
| pot4 | フィードバック | 0〜100% |

エコーとの違い: ディレイ時間がLFOで変調される → 「うねり」感

```c
float d = 1 + effect_delay * (1 + lfo_step(...) * effect_depth);
```

#### phaser (フェイザー)

```
phaser_defaults = 0.3 0.3 0.5 0.5
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | LFO周期 | 25〜2000 ms (3乗) |
| pot2 | フィードバック | 0〜75% |
| pot3 | 中心周波数 | 50〜880 Hz |
| pot4 | Q値 | 0.25〜2 |

**コア処理**: 4段のオールパスフィルタを直列接続

```c
float phaser_step(float in) {
    float lfo = lfo_step(&phaser.lfo, lfo_triangle);
    float freq = fastpow(2, lfo*phaser.octaves) * phaser.center_f;

    _biquad_allpass_filter(&phaser.coeff, freq, phaser.Q);

    out = in + phaser.feedback * phaser.s3[0];
    out = biquad_step_df1(...);  // 4段
    out = biquad_step_df1(...);
    out = biquad_step_df1(...);
    out = biquad_step_df1(...);

    return limit_value(in + out);
}
```

オールパスフィルタは振幅を変えず位相だけをずらす。LFOで周波数を変調すると、位相差が変化して干渉パターンが生まれる。

#### fm (FM合成)

```
fm_defaults = 0.25 0.25 0.5 0.5
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | 音量 | 0〜100% |
| pot2 | 基本周波数 | 100〜8100 Hz |
| pot3 | 変調深さ | ±1オクターブ |
| pot4 | モジュレータ周波数 | 1〜11 Hz |

入力を無視して音を生成するテスト用。

#### am (AM合成)

```
am_defaults = 0.5 0.5 0.5 0.5
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | 音量 | 0〜100% |
| pot2 | キャリア周波数 | 100〜8100 Hz |
| pot3 | 変調深さ | 0〜100% |
| pot4 | モジュレータ周波数 | 1〜11 Hz |

同じくテスト用信号生成。

#### discont (ピッチシフター)

```
discont_defaults = 0.8 0.1 0.2 0.2
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | ピッチ比 | 0.5〜2倍 |
| pot2〜4 | (未使用) | - |

sin²/cos² でクロスフェードして不連続点を隠す手法。

#### distortion (歪み)

```
distortion_defaults = 0.5 0.6 0.8 0.0
```

| pot | 意味 | 範囲 |
|-----|------|------|
| pot1 | ドライブ | 1〜50倍 |
| pot2 | トーン | 1〜10 kHz (LPF) |
| pot3 | 出力レベル | 0〜100% |
| pot4 | モード | soft/hard/asymmetric |

```c
// ソフトクリップ (tanh近似)
float soft_clip(float x) {
    return x / (1.0f + fabsf(x));
}
```

---

## 全エフェクト出力の生成

```bash
cd /Users/aki/git.local/AudioNoise
for eff in flanger echo fm phaser discont am distortion; do
    ./convert $eff <defaults> < input.raw > ${eff}.raw
done
```

生成されたファイル:
- `flanger.raw`, `echo.raw`, `fm.raw`, `phaser.raw`
- `discont.raw`, `am.raw`, `distortion.raw`

visualize.py で比較可能:
```bash
python visualize.py input.raw phaser.raw flanger.raw
```

---

## 可視化による観察

### echo の暴走

```bash
python visualize.py input.raw phaser.raw flanger.raw echo.raw
```

- 2.0秒以降、echo が ±1.0 に完全飽和
- フィードバック 30% でも信号が累積してオーバーフロー
- 0.7秒付近の静かな部分で減衰テール（300msごとに70%減衰）が確認できた

### distortion の増幅

```bash
python visualize.py input.raw distortion.raw
```

- drive=25.5倍で入力が大幅に増幅
- 静かな部分（1.0〜1.35秒）でもノイズが25倍に
- 1.4秒以降は完全にクリッピング
- **音量注意**: 耳が死ぬ

### 再生方法

```bash
# 直接再生
ffplay -v fatal -nodisp -autoexit -f s32le -ar 48000 -ch_layout mono phaser.raw

# MP3に変換して再生
ffmpeg -f s32le -ar 48000 -ac 1 -i distortion.raw distortion.mp3
open distortion.mp3
```
